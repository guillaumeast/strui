# 🛠️ **`strui` v1.0.0**

Tiny Unicode‑aware & ANSI‑aware **string CLI** – built on top of [`libstrui`](https://github.com/guillaumeast/libstrui).

[![C++](https://img.shields.io/badge/language-C%2B%2B17-blue)](https://en.cppreference.com/)
[![Type: CLI](https://img.shields.io/badge/type-CLI-lightgrey)](https://en.wikipedia.org/wiki/Command-line_interface)
[![Platform: Unix](https://img.shields.io/badge/platform-Unix-darkgreen)](https://en.wikipedia.org/wiki/Unix)
[![Status: v1.0.0](https://img.shields.io/badge/status-v1.0.0-brightgreen)](https://github.com/guillaumeast/strui/releases/tag/v1.0.0)

> **`strui`** is the command‑line face of `libstrui`:  
> think of it as a minimal, UTF‑8‑smart replacement for `cut`, `wc`, or `tr` that understands emojis and ANSI escapes.

---

## ✨ Features

- Everything from **`libstrui`** available at the tips of your fingers:
  - clean ANSI escapes
  - measure *visual* width / height
  - split / join / repeat helpers
  - substring count
- **UTF‑8 aware** (CJK, wide & combined emojis)
- **Zero runtime dependencies** – the binary is **fully self-contained**
- Ships as **one small binary** (`<50 KB`)

---

### 🚀 Quick install

```bash
curl -fsSL https://raw.githubusercontent.com/guillaumeast/strui/master/install/install.sh | sh
```

This will:

- detect your platform (Linux/macOS, x86_64/arm64),
- download the right binary from the latest release,
- install it to `~/.local/bin` (or a custom path if you set `$DEST`),
- add `~/.local/bin` in your `$PATH` if not already in.
- and verify checksum before running anything.

> 🙈 If you're on `Windows`:  
> Don’t worry — we all make mistakes.  
> Fire up `wsl`, and pretend it never happened.  
>   
> ✨ Join us on the bright (terminal) side.

---

## 📦 Dependencies

- **Runtime:** None
- **Build-time:**
    - [`libunistring`](https://www.gnu.org/software/libunistring/) ≥ 1.1 (**statically linked**)
    - Any **C++17** compiler (`g++`, `clang++`, …)

---

## 🖥️ Usage

| Command                                                | Description                                   |
|--------------------------------------------------------|-----------------------------------------------|
| `strui width <string>`                                 | Return *visual* width (columns) of `string`   |
| `strui height <string>`                                | Return number of *lines* in `string`          |
| `strui clean <string>`                                 | Remove ANSI *escape sequences*                |
| `strui split <string> <separator>`                     | Vector‑split `string` on `separator`          |
| `strui join ?--separator ?<separator> <...strings...>` | Join `strings` with optional `separator`      |
| `strui repeat <count> <string> ?<separator>`           | Repeat `string` `count` times                 |
| `strui count <value> <string>`                         | Count occurrences of `value` in `string`      |

> `Display width` is measured in `columns`, of `characters` or `strings`, when output to a device that uses `non-proportional fonts`.  
> Note that for some rarely used characters the actual `fonts` or `terminal emulators` can use a different `width`. There is no mechanism for communicating the `display width` of `characters` across a Unix pseudo-terminal (`tty`).  
> Also, there are scripts with complex rendering, like the `Indic` scripts. For these scripts, there is no such concept as `non-proportional fonts`. Therefore the results of these functions usually work fine on most scripts and on most `characters` but can fail to represent the actual `display width`.  
> 📚 See [libunistring documentation – Display width <uniwidth.h>](https://www.gnu.org/software/libunistring/manual/libunistring.html#uniwidth_002eh) for details on how display width is computed.

---

## 🧪 Tests

> Requirement: Docker

Tests are run locally and **inside an Ubuntu container** to guarantee portability.

```bash
make test          # build + tests
```

---

## 📁 Project structure

```
strui/
├── Makefile
├── include/strui.hpp   # libstrui header
├── src/main.cpp        # CLI implementation
├── build/              # autogenerated binary (can be .gitignored)
└── tests/
    ├── volume/         # auto-generated at runtime by `run.sh` (can be .gitignored)
    ├── run.sh          # test orchestrator (POSIX sh)
    ├── test.sh         # unit tests (POSIX sh)
    └── Dockerfile      # ubuntu image description for portability tests
```

---

## 👤 Author

Made with ❤️ by [@guillaumeast](https://github.com/guillaumeast)
